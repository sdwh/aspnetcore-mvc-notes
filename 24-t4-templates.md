# ASP.NET Core MVC 教學 (.NET 8)：使用 T4 程式碼範本快速開發網站

在軟體開發過程中，我們經常會編寫大量結構相似、遵循特定模式的「樣板程式碼 (Boilerplate Code)」。例如，為每個資料庫實體建立對應的 Repository 類別、服務介面、DTOs，甚至是基本的 CRUD (Create, Read, Update, Delete) Controller Actions 和 Views。手動編寫這些程式碼不僅耗時、乏味，而且容易出錯。

為了解決這個問題，Visual Studio 提供了一種強大的程式碼產生技術——**T4 範本 (Text Template Transformation Toolkit)**。T4 允許你建立一個包含 C# 邏輯的文字範本檔案 (`.tt`)，這個範本可以讀取外部資料（如資料庫結構、XML 檔案，或透過反射讀取現有類別），並根據這些資料動態地產生程式碼檔案（如 `.cs`, `.html`, `.sql` 等）。

## 1. 什麼是 T4 範本？

一個 T4 範本檔案 (`.tt`) 主要由兩部分組成：

1.  **靜態文字區塊**：這部分是你希望直接輸出到最終檔案的內容，例如 `using` 語句、類別宣告的固定部分等。
2.  **控制邏輯區塊**：這部分是嵌入在 `<# ... #>` 標記中的 C# 程式碼。你可以使用迴圈、條件判斷、呼叫方法等來動態地產生文字。

### T4 控制區塊的類型：
*   **`<# ... #>` (標準控制區塊)**: 用於編寫流程控制程式碼，如 `for` 迴圈、`if` 語句。
*   **`<#= ... #>` (運算式控制區塊)**: 用於將一個 C# 運算式的結果直接輸出到檔案中，類似於 Razor 的 `@`。
*   **`<#+ ... #>` (類別功能控制區塊)**: 用於定義輔助方法或屬性，這些方法可以在範本的其他地方被呼叫。
*   **`<#@ ... #>` (指令區塊)**: 用於設定範本的處理方式，例如 `import` 命名空間、`assembly` 引用外部組件、`parameter` 接收外部參數等。

## 2. 應用場景：自動產生 Repository

假設我們的專案中有多個資料實體 (Entity)，如 `Product`, `Order`, `Customer` 等。我們希望為每一個實體都自動產生一個對應的 Repository 介面和一個具體的 Repository 類別。

### 步驟 1：準備工作

確保你的專案中已經定義好了資料實體，並且有一個 `DbContext`。

### 步驟 2：建立 T4 範本檔案

1.  在你的專案中，新增一個資料夾，例如 `DataAccess/Repositories/T4`。
2.  右鍵點擊該資料夾 -> **加入 (Add)** -> **新增項目 (New Item)**。
3.  在搜尋框中輸入 "Text"，選擇「**文字範本 (Text Template)**」，並將其命名為 `RepositoryGenerator.tt`。

### 步驟 3：編寫 T4 範本

打開 `RepositoryGenerator.tt`，貼上以下程式碼。這個範本會使用**反射 (Reflection)** 來讀取你專案中所有繼承自 `BaseEntity` 的類別，並為它們產生 Repository。

**`RepositoryGenerator.tt`**
```csharp
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)MyWebApp\bin\Debug
et8.0\MyWebApp.dll" #> <#-- **重要：替換成你專案 DLL 的實際路徑** -->
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="MyWebApp.Models.Entities" #> <#-- **重要：替換成你實體所在的命名空間** -->
<#@ output extension=".generated.cs" #>

// <auto-generated>
//     This code was generated by a T4 template.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using MyWebApp.Models.Entities; // 根據需要修改
using MyWebApp.Data; // 根據需要修改

namespace MyWebApp.DataAccess.Repositories
{
<#
    // 透過反射獲取所有繼承自 BaseEntity 的實體類別
    var entityTypes = typeof(BaseEntity).Assembly.GetTypes()
        .Where(t => t.IsClass && !t.IsAbstract && t.IsSubclassOf(typeof(BaseEntity)));

    foreach (var entityType in entityTypes)
    {
        string entityName = entityType.Name;
        string repositoryInterfaceName = $"I{entityName}Repository";
        string repositoryClassName = $"{entityName}Repository";
#>
    //================================================================================
    // Interface for <#= entityName #>
    //================================================================================
    public partial interface <#= repositoryInterfaceName #> : IGenericRepository<<#= entityName #>>
    {
        // 你可以在這裡為特定介面加入額外的方法定義
    }

    //================================================================================
    // Repository for <#= entityName #>
    //================================================================================
    public partial class <#= repositoryClassName #> : GenericRepository<<#= entityName #>>, <#= repositoryInterfaceName #>
    {
        public <#= repositoryClassName #>(ApplicationDbContext context) : base(context)
        {
        }

        // 你可以在這裡為特定類別加入額外的方法實作
    }

<#
    } // end foreach
#>
}
```
**重要設定：**
*   **`<#@ assembly ... #>`**: 這個指令告訴 T4 引擎需要載入哪個組件的 DLL 檔案，以便能夠反射其中的型別。你必須將 `$(SolutionDir)MyWebApp\bin\Debug
et8.0\MyWebApp.dll` 替換成你自己專案編譯後的 DLL 路徑。
*   **`<#@ import ... #>`**: 引入你實體所在的命名空間。
*   **`<#@ output extension=".generated.cs" #>`**: 指定產生的檔案副檔名。

### 步驟 4：執行範本轉換

儲存 `RepositoryGenerator.tt` 檔案。Visual Studio 會自動執行 T4 範本轉換，並在它下面產生一個名為 `RepositoryGenerator.generated.cs` 的檔案。

打開這個產生的檔案，你會看到所有 Repository 的介面和類別都已經被自動建立好了！

```csharp
// RepositoryGenerator.generated.cs (產生的檔案)

// <auto-generated>
// ...
// </auto-generated>

namespace MyWebApp.DataAccess.Repositories
{
    //================================================================================
    // Interface for Product
    //================================================================================
    public partial interface IProductRepository : IGenericRepository<Product>
    {
    }

    //================================================================================
    // Repository for Product
    //================================================================================
    public partial class ProductRepository : GenericRepository<Product>, IProductRepository
    {
        public ProductRepository(ApplicationDbContext context) : base(context)
        {
        }
    }

    // ... 其他實體的 Repository ...
}
```

## 3. T4 的優勢與注意事項

### 優勢：
1.  **大幅減少樣板程式碼**：將開發人員從重複、枯燥的編碼工作中解放出來。
2.  **保持一致性**：所有產生的程式碼都遵循同一個範本，確保了程式碼風格和結構的統一。
3.  **提高生產力**：當新增一個新的資料實體時，只需要重新執行一次 T4 範本轉換，所有相關的 Repository 就會被自動產生，無需手動建立。
4.  **高度自訂**：你可以完全控制產生的程式碼的內容和格式。

### 注意事項：
1.  **設定複雜**：T4 範本的初始設定（特別是 `assembly` 路徑）可能有點棘手，需要確保路徑正確。
2.  **不要直接修改產生的檔案**：所有對 `*.generated.cs` 檔案的修改，在下一次範本轉換時都會被覆蓋掉。如果你需要為某個特定的 Repository 加入自訂邏輯，應該利用 `partial class` 的特性，在另一個手動建立的檔案中進行擴充。
3.  **偵錯困難**：T4 範本的偵錯不如標準 C# 程式碼直觀。
4.  **替代方案**：在 .NET Core 時代，**原始碼產生器 (Source Generators)** 成為了一個更現代、更強大的替代方案。Source Generators 在編譯期間執行，可以更無縫地與編譯過程整合，但 T4 範本因其簡單直觀，對於很多場景仍然是一個非常實用的工具。

## 結論

T4 範本是一個被低估但非常強大的程式碼產生工具。當你的專案中存在大量需要遵循固定模式的重複程式碼時，投入時間建立一個 T4 範本，將會在長期開發和維護中為你節省大量的時間和精力。

從自動產生 Repositories、Services、DTOs，到產生前端的 TypeScript 型別定義，甚至是產生 SQL 腳本，T4 範本都能夠勝任，是提升開發自動化程度的利器。
